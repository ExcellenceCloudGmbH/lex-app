### prompts/prompts.yaml
BLUE_PRINT_PROMPT: |
    Analyze my Python project files and generate a detailed project blueprint that includes the following information:

    ### 1. **Project Overview**
       - Project Name, Version, and Author (if available).
       - High-level description of the project's functionality and purpose.
       - Key features or functionalities implemented in the project.
       - Entry point of the project (main script or function).

    ### 2. **Project Structure**
       - Directory structure with descriptions for each folder and file. Highlight the purpose of each significant file (e.g., `main.py` for project entry, `config.py` for configuration).
       - Identify and document the roles of core modules and scripts.

    ### 3. **Dependency and Environment Details**
       - List of all external libraries and dependencies used in the project, including their versions (extracted from `requirements.txt`, `setup.py`, or `pyproject.toml`).
       - Specify Python version and any other system requirements needed to run the project.
       - Configuration details like environment variables and configuration files (e.g., `.env`, `settings.py`).

    ### 4. **Module and Class Descriptions**
       - List all modules, classes, and key functions within the codebase.
       - Try to be as descriptive as possible about the purpose and functionality of each module or class.
       - For each class or module, provide:
         - A detailed description of its purpose.
         - Key attributes and methods, along with input parameters and return types.
         - Description of interdependencies and communication between modules.
       
    ### 5. **Data Models and Schemas**
       - Describe any data models or schemas used in the project (e.g., ORM models, JSON schemas).
       - Provide a complete overview of the database structure, if applicable, including tables, fields, and relationships.

    ### 6. **Configuration and Setup Instructions**
       - Configuration options and parameters that need to be set before running the project.
       - Step-by-step setup instructions, including installing dependencies, configuring environment variables, and setting up databases or external services.

    ### 7. **External Integrations and APIs**
       - Describe any external APIs or services integrated with the project.
       - Provide details on the modules or scripts responsible for handling these integrations.

    ### 8. **Code Flow and Execution**
       - High-level overview of how data flows through the project.
       - Describe the sequence of execution starting from the entry point to major operations and outputs.

    ### 9. **Testing and Debugging**
       - List all test files and test cases defined within the project.
       - Describe the testing framework used and how to run tests.
       - Provide debugging tips or known issues, if applicable.

    ### 10. **Documentation and Comments Analysis**
       - Extract and summarize inline comments and docstrings for each module, class, and function.
       - Generate a report on the quality and coverage of documentation.

    ### 11. **Additional Notes**
       - Any other relevant information that would be helpful for understanding and recreating the project.
       - Recommendations for improving or extending the project.

    Generate this blueprint in a structured and formatted manner, similar to a comprehensive README or project documentation.
    Explain as much as possible in a summary what does this project do, the use cases and everything that is important to know about this project.

BLUE_PRINT_PROMPT_2: |
    I need a complete and detailed project blueprint based on the following Django project files...
    # Copy the full content from BLUE_PRINT_PROMPT_2 in the original class

BLUE_PRINT_REVIEW_PROMPT: |
    Review the generated project code to ensure it matches the specifications...
    # Copy the full content from BLUE_PRINT_REVIEW_PROMPT in the original class

PROMPT_REQUIREMENT: |
    1. Write a project which is explained in the given context as project description
    2. Read and understand the lex-app library source code which is again included fully inside the given context.
    3. In cases where you have to extend Django models class, instead you have to extend the lex-app library LexModel class.
    4. DO NOT forget to import everything necessary for the code you will write and everytime you change something double check this requirement.
    5. In the places which requires business logic calculations, use the lex-app library CalculationModel class where you extend the calculate method.
    6. In the places which requires uploads or downloads, use the lex-app library CalculationModel class where you extend the calculate method because it also works for post upload operations and to create the files will be downloaded.
    7. When an excel creation or update is needed, use the lex-app library XLSXField and its create_excel_file_from_dfs function.
    8. In the case of Excel FileField usage for any Django Model classes you will write, use the lex-app library XLSXField class.
    9. Put logs in meaningful places in your code such as calculations and use the lex-app library MarkdownBuilder class from the LexLogger class.
    10. Add primary keys to the Django Model classes you will create in below format:
         id = models.AutoField(primary_key=True)
    11. Use ForeignKey fields for the relationships between the models when it is applicable according to the project design and PLEASE USE THE CORRECT COLUMN NAMES FROM DATA SAMPLE DON"T USE SOMETHING THAT DOESN'T EXIST.
    12. For every code file, write relative file paths which includes meaningful folders in this format and remember the path for imports later
        ### <example_dir1>/<example_dir2>/<example_file>.py
        ```python
    13. Don't forget to implement the necessary buisness logic in the calculate method of the CalculationModel class.
    14. LexLogger shall only be used for CalculationModel classes and CalculationModel class's calculate
    15. Double check the imports from the lex_app context or if you use any foreign key relationship
    

REFINED_PROMPT_REQUIREMENT: |
    1. **Full Implementation Required**: You are tasked with generating...
    # Copy the full content from REFINED_PROMPT_REQUIREMENT in the original class

REFINED_BLUE_PRINT_PROMPT: |
    **[YOU ARE A SOFTWARE ENGINEER AND YOU ARE TASKED TO IMPLEMENT EVERYTHING IN THE PROJECT]**...
    # Copy the full content from REFINED_BLUE_PRINT_PROMPT in the original class

VALIDATION: |
    ### **Instructions**:
    for each class seperatly do this:...
    # Copy the full content from VALIDATION in the original class

VALIDATION_2: |
    Here's a more **concise and strict** version of the prompt...
    # Copy the full content from VALIDATION_2 in the original class